#define CHECK_REMAINED_SIZE(actual_len, label) \
    if (_ptr < _bytecode || _bytecode_len - static_cast<int64_t>(_ptr - _bytecode) < actual_len) {\
        throw std::runtime_error("Out of range. Label: " + std::string(#label));\
    }

{% for instruction in instructions %}

void Interpretator::do_{{ instruction.mnemonic }}() {
    CHECK_REMAINED_SIZE({{ instruction.len_without_vector }}, do_{{ instruction.mnemonic }});
    _ptr++;

{% for arg in instruction.args %}
{% if arg["type"] == 'RegType' %}
    int64_t &_arg{{ loop.index0 }} = GetRegRef(*_ptr++);  // register
{%- elif arg["type"] == 'LongType' %}
    const int64_t &_arg{{ loop.index0 }} = *_ptr++;       // long
{%- elif arg["type"] == 'FuncIdType' %}
    const int64_t &_arg{{ loop.index0 }} = *_ptr++;       // func_id
{%- elif arg["type"] == 'VectorLenType' %}
    const int64_t &_arg{{ loop.index0 }} = *_ptr++;       // vector_len
{%- elif arg["type"] == 'VectorType' %}
    CHECK_REMAINED_SIZE(_arg{{ loop.index0 - 1}}, do_{{ instruction.mnemonic }});
    std::vector<int64_t> _arg{{ loop.index0 }};
    for (int i = 0; i < _arg{{ loop.index0 - 1}}; ++i) {
        _arg{{ loop.index0 }}.push_back(*_ptr++);
    }
{%- else %}
    throw std::runtime_error("Unreachable type in do");
{%- endif -%}
{% endfor %}

    {{ instruction.logic }}
}

void Interpretator::dump_{{ instruction.mnemonic }}() {
    CHECK_REMAINED_SIZE({{ instruction.len_without_vector }}, dump_{{ instruction.mnemonic }});
    std::cout << static_cast<int64_t>(_ptr - _bytecode) << ": {{ instruction.mnemonic }}";
    _ptr++;

{% for arg in instruction.args %}
{% if arg["type"] == 'RegType' %}
    std::cout << ", r" << *_ptr++;          // register
{%- elif arg["type"] == 'LongType' %}
    std::cout << ", " << *_ptr++;           // long
{%- elif arg["type"] == 'FuncIdType' %}
    std::cout << ", #" << *_ptr++;          // func_id
{%- elif arg["type"] == 'VectorLenType' %}
    auto _arg{{ loop.index0 }} = *_ptr;
    std::cout << ", " << *_ptr++;           // vector_len
{%- elif arg["type"] == 'VectorType' %}
    CHECK_REMAINED_SIZE(_arg{{ loop.index0 - 1}}, dump_{{ instruction.mnemonic }});
    for (int i = 0; i < _arg{{ loop.index0 - 1}}; ++i) {
        std::cout << ", " << *_ptr++;
    }
{%- else %}
    throw std::runtime_error("Unreachable type in dump");
{%- endif -%}
{% endfor %}

    std::cout << std::endl;
}

void Interpretator::create_{{ instruction.mnemonic }}({{ instruction.create_args|join(', ') }}) {
    CHECK_REMAINED_SIZE({{ instruction.len_without_vector }}, create_{{ instruction.mnemonic }});

    *_ptr = {{ instruction.opcodeDec }};
    _ptr++;
{% for arg in instruction.args %}
{% if arg["type"] != 'VectorType' %}
    *_ptr++ = arg{{ loop.index0 }};
{%- else %}
    CHECK_REMAINED_SIZE(arg{{ loop.index0 - 1 }}, create_{{ instruction.mnemonic }});
    for (auto arg : arg{{ loop.index0 }}) {
        *_ptr++ = arg;
    }
{%- endif -%}
{% endfor %}
}

{% endfor %}
