{% for instruction in instructions %}

uint8_t Interpretator::do_{{ instruction.mnemonic }}(uint8_t *ptr) {
    ptr++;

{% for arg in instruction.args %}
{% if arg["type"] == 'RegType' %}
    uint64_t &_arg{{ loop.index0 }} = GetRegRef(*reinterpret_cast<{{ arg["type"] }} *>(ptr));
    ptr += 1;
{%- else %}
    const uint64_t _arg{{ loop.index0 }} = *reinterpret_cast<{{ arg["type"] }} *>(ptr);
    ptr +=  8;
{%- endif -%}
{% endfor %}

    {{ instruction.logic }}
    return {{ instruction.len }};
}

uint8_t Interpretator::create_{{ instruction.mnemonic }}({{ instruction.create_args|join(', ') }}, uint8_t *ptr, uint64_t size) {
    if (size < {{ instruction.len }}) {
        throw std::runtime_error("Out of range in create_{{ instruction.mnemonic }}");
    }

    *reinterpret_cast<uint8_t*>(ptr) = {{ instruction.opcodeDec }};
    ptr++;
{% for arg in instruction.args %}
{% if arg["type"] == 'RegType' %}
    *reinterpret_cast<uint8_t*>(ptr) = _arg{{ loop.index0 }};
    ptr += 1;
{%- else %}
    *reinterpret_cast<uint64_t*>(ptr) = _arg{{ loop.index0 }};
    ptr +=  8;
{%- endif -%}
{% endfor %}

    return {{ instruction.len }};
}

{% endfor %}

