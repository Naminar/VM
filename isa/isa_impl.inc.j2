{% for instruction in instructions %}

void Interpretator::do_{{ instruction.mnemonic }}() {
    _ptr++;

{% for arg in instruction.args %}
{% if arg["type"] == 'RegType' %}
    int64_t &_arg{{ loop.index0 }} = GetRegRef(*reinterpret_cast<uint8_t *>(_ptr));
    _ptr += 1;
{%- else %}
    const int64_t _arg{{ loop.index0 }} = *reinterpret_cast<int64_t *>(_ptr);
    _ptr +=  8;
{%- endif -%}
{% endfor %}

    {{ instruction.logic }}
}

void Interpretator::dump_{{ instruction.mnemonic }}() {
    uint64_t offset = static_cast<uint64_t>(_ptr - _bytecode);
    std::cout << offset << ": {{ instruction.mnemonic }}";
    _ptr++;

{% for arg in instruction.args %}
{% if arg["type"] == 'RegType' %}
    std::cout << ", r" << static_cast<int64_t>(*reinterpret_cast<uint8_t *>(_ptr));
    _ptr += 1;
{%- else %}
    std::cout << ", " << static_cast<int64_t>(*reinterpret_cast<int64_t *>(_ptr));
    _ptr +=  8;
{%- endif -%}
{% endfor %}

    std::cout << std::endl;
}

void Interpretator::create_{{ instruction.mnemonic }}({{ instruction.create_args|join(', ') }}) {
    uint64_t size_remained = _bytecode_len - static_cast<uint64_t>(_ptr - _bytecode);

    if (size_remained < {{ instruction.len }}) {
        throw std::runtime_error("Out of range to create_{{ instruction.mnemonic }}");
    }

    *reinterpret_cast<uint8_t*>(_ptr) = {{ instruction.opcodeDec }};
    _ptr++;
{% for arg in instruction.args %}
{% if arg["type"] == 'RegType' %}
    *reinterpret_cast<uint8_t *>(_ptr) = arg{{ loop.index0 }};
    _ptr += 1;
{%- else %}
    *reinterpret_cast<int64_t *>(_ptr) = arg{{ loop.index0 }};
    _ptr +=  8;
{%- endif -%}
{% endfor %}
}


{% endfor %}



void Interpretator::do_call() {
    _ptr++;

    const int64_t func_id = *reinterpret_cast<int64_t *>(_ptr);
    _ptr +=  8;
    const int64_t n_args = *reinterpret_cast<int64_t *>(_ptr);
    _ptr +=  8;

    std::vector<uint8_t> args;

    for (uint64_t i = 0; i < n_args; ++i) {
        args.push_back(*reinterpret_cast<uint8_t *>(_ptr));
        _ptr++;
    }

    _current_frame->_ptr = _ptr;

    // new frame and push
    Frame* new_frame = new Frame(GetFuncById(func_id)->_n_regs);
    for (uint64_t i = 0; i < args.size(); ++i) {
        new_frame->_regs[i] = GetRegRef(args[i]);
    }

    _current_frame = new_frame;
    _frames.push(new_frame);
    _ptr = GetFuncById(func_id)->_bytecode;
}

void Interpretator::dump_call() {
    uint64_t offset = static_cast<uint64_t>(_ptr - _bytecode);
    std::cout << offset << ": call";
    _ptr++;

    const int64_t func_id = *reinterpret_cast<int64_t *>(_ptr);
    _ptr +=  8;

    std::cout << " #f" << func_id << " (" << GetFuncById(func_id)->_name << ")";

    const int64_t n_args = *reinterpret_cast<int64_t *>(_ptr);
    std::cout << ", " << static_cast<int64_t>(n_args);
    _ptr +=  8;


    for (uint64_t i = 0; i < n_args; ++i) {
        std::cout << ", r" << static_cast<int64_t>(*reinterpret_cast<uint8_t *>(_ptr));
        _ptr++;
    }

    std::cout << std::endl;
}

void Interpretator::create_call(uint64_t func_id, uint64_t n_args, std::vector<uint8_t> args) {
    uint64_t size_remained = _bytecode_len - static_cast<uint64_t>(_ptr - _bytecode);

    if (size_remained < 17 + n_args) {
        throw std::runtime_error("Out of range to create_call");
    }


    *reinterpret_cast<uint8_t*>(_ptr) = OPCODE_CALL;
    _ptr++;
    *reinterpret_cast<uint8_t*>(_ptr) = func_id;
    _ptr +=  8;
    *reinterpret_cast<uint8_t*>(_ptr) = n_args;
    _ptr +=  8;

    for (auto arg : args) {
        *reinterpret_cast<uint8_t *>(_ptr) = arg;
        _ptr++;
    }
}


void Interpretator::do_lreturn() {
    _ptr++;

    _return_value = GetRegRef(*reinterpret_cast<uint8_t *>(_ptr));
    _ptr++;

    delete _current_frame;
    _frames.pop();
    _current_frame = _frames.top();
    _ptr = _current_frame->_ptr;
}


void Interpretator::dump_lreturn() {
    uint64_t offset = static_cast<uint64_t>(_ptr - _bytecode);
    std::cout << offset << ": ";
    _ptr++;

    uint8_t reg = *reinterpret_cast<uint8_t *>(_ptr);
    _ptr++;

    std::cout << "lreturn r" << static_cast<int64_t>(reg) << std::endl;
}


void Interpretator::create_lreturn(uint8_t reg) {
    uint64_t size_remained = _bytecode_len - static_cast<uint64_t>(_ptr - _bytecode);

    if (size_remained < 7) {
        throw std::runtime_error("Out of range to create_call");
    }


    *reinterpret_cast<uint8_t*>(_ptr) = OPCODE_LRETURN;
    _ptr++;
    *reinterpret_cast<uint8_t *>(_ptr) = reg;
    _ptr++;
}
